#signal.h
信号是UNIX和Linux系统响应某些条件而产生的一个事件。接收到该信号的进程会相应地采取一些行动。我们用术语生成`raise`表示一个信号的产生，使用术语捕获`catch`表示接收到一个信号。      
信号是由于某些错误条件而生成的，如内存段冲突、浮点处理器错误或非法指令等。它们由shell和终端处理器生成来引起中断，它们还可以作为在进程间传递消息或修改行为的一种方式，明确地由一个进程发送给另一个进程。无论何种情况，它们的编程接口都是相同的。信号可以被生成、捕获、响应或(至少对于一些信号)忽略。           
信号的名称是在头文件`signal.h`中定义的，它们以SIG开头
```text
信号名称     说明
SIGABORT     进程异常终止
SIGALRM      超时警告
SIGFPE       浮点运算异常
SIGHUP       连接挂断
SIGILL       非法指令
SIGINT       终端中断
SIGKILL      终止进程(此信号不能被捕获或忽略)
SIGPIPE      向无读进程的管道写数据
SIGQUIT      终端退出
SIGSEGV      无效内存段访问
SIGTERM      终止
SIGUSR1      用于定义信号1
SIGUSR2      用于定义信号2
```
如果进程接收到这些信号中的一个，但事先没有安排捕获它，进程将会立刻终止。通常，系统将生成核心转储文件core，并将其放在当前目录下。该文件是进程在内存中的影像，它对程序的调试很有用处。
```text
信号名称     说明
SIGCHLD      子进程已经停止或退出
SIGCONT      继续执行暂停进程
SIGSTOP      停止执行(此信号不能被捕获或忽略)
SIGTSTP      终端挂起
SIGTTIN      后台进程尝试读操作
SIGTTOU      后台进程尝试写操作
```
SIGCHLD信号对于管理子进程很有用。默认情况下，它是被忽略的。其余的信号会使接收它们的进程停止运行，但SIGCHLD是个例外，它的作用是让进程恢复并继续执行。shell脚本通过它来控制作业，但用户程序很少会用到它。           
现在，我们只需知道如果shell和终端驱动程序是按通常情况配置的话，在键盘上敲入中断字符(通常是Ctrl+C组合键)就会向前台进程(即当前正在运行的程序)发送SIGINT信号，这将引起该程序的终止，除非它事先安排了捕获这个信号。         
如果发送一个信号给进程，而该进程并不是当前的前台进程，就需要使用kill命令。该命令需要有一个可选的信号代码或信号名称和一个接收信号的目标进程的PID(这个PID一般需要用ps命令查出来)。例如，如果要向运行在另一个终端上的PID为512的进程发送"挂断"信号，可以使用如下命令:
```bash
kill -HUP 512
```
kill命令有一个有用的变体叫killall，它可以给运行着某一命令的所有进程发送信号。并不是所有的UNIX系统都支持它，但Linux系统一般都有该命令。如果不知道某个进程的PID，或者想给执行相同命令的许多不同的进程发送信号，这条命令就很有用了。一种常用的用法是，通知inetd程序重新读取它的配置选项，要完成这一工作，可以使用下面这条命令:
```bash
killall -HUP inetd
```
程序可以用signal库函数来处理信号，它的定义如下:
```c
#include <signal.h>

void (*signal(int sig, void (*func)(int))) (int);
```
这个相当复杂的函数定义说明，signal是一个带有sig和func两个参数的函数。准备捕获或忽略的信号由参数sig给出，接收到指定的信号后将要调用的函数由参数func给出。信号处理函数必须有一个int类型的参数(即接收到的信号代码)并且返回类型为void。signal函数本身也返回一个同类型的函数，即先前用来处理这个信号的函数，或者也可以用以下两个特殊值之一来代替信号处理函数
```text
SIG_IGN    忽略信号
SIG_DFL    恢复默认行为
```
通过一个实例可以更清楚地理解信号的处理方法。下面我们来编写一个程序，它将响应用户敲入的Ctrl+C组合键，在屏幕上打印一条适当的消息而不是终止程序的运行。当用户第二次按下Ctrl+C时，程序将结束运行。
#####信号处理
函数ouch对通过参数sig传递进来的信号作出响应。信号出现时，程序调用该函数，它先打印一条消息，然后将信号SIGINT(默认情况下，按下Ctrl+C将产生这个信号)的处理方式恢复为默认行为。
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void ouch(int signum)
{
	printf("OUCH - %d\n", signum);
	signal(SIGINT, SIG_DFL);
}

int main(int argc, char *argv[])
{
	signal(SIGINT, ouch);

	while(1) {
		printf("hello world\n");
		sleep(1);
	}
	return 0;
}
```
在本例中我们可以看到，信号处理函数使用了一个单独的整数参数，它就是引起该函数被调用的信号代码。如果需要在同一个函数中处理多个信号，这个参数就很有用。在本例中，我们打印出SIGINT的值，它的值在这个系统中恰好是2，但你不能过分依赖传统的信号数字值，而应该在新的程序中总是使用信号的名字。             
在此例中我们可以看到，调用如printf这样的函数是不安全的。一个有用的技巧是，在信号处理函数中设置一个标志，然后在主程序中检查该标志，如需要就打印一条消息。            
signal函数返回的是先前对指定信号进行处理的信号处理函数的函数指针，如果未定义信号处理函数，则返回SIG_ERR并设置errno为一个正数值。如果给出的是一个无效的信号，或者尝试处理的信号是不可捕获或不可忽略的信号(如SIGKILL)，errno将被设置为EINVAL。        
#####发送信号
进程可以通过调用kill函数向包括它本身在内的其他进程发送一个信号。如果程序没有发送该信号的权限，对kill函数的调用就将失败，失败的常见原因是目标进程由另一个用户所拥有。这个函数和同名的shell命令完成相同的功能，它的定义如下所示：
```c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```
kill函数把参数sig给定的信号发送给由参数pid给出的进程号所指定的进程，成功时它返回0。要想发送一个信号，发送进程必须拥有相应的权限。这通常意味着两个进程必须拥有相同的用户ID(即你只能发送信号给属于自己的进程，但超级用户可以发送信号给任何进程)。         
kill调用会在失败时返回-1并设置errno变量。失败的原因可能是：给定的信号无效(errno设置为EINVAL)：发送进程权限不够(errno设置为EPERM)；目标进程不存在(errno设置为ESRCH)。           
信号向我们提供了一个有用的闹钟功能。进程可以通过调用alarm函数在经过预定时间后发送一个SIGALRM信号。
```c
#include <unistd.h>

unsigned int alarm(unsigned int seconds);
```
alarm函数用来在seconds秒之后安排发送一个SIGALRM信号。但由于处理的延时和时间调度的不确定性，实际闹钟时间将比预先安排的要稍微拖后一点儿。把参数seconds设置为0将取消所有已设置的闹钟请求。如果在接收到SIGALRM信号之前再次调用alarm函数，则闹钟重新开始计时。每个进程只能有一个闹钟时间。alarm函数的返回值是以前设置的闹钟时间的余留秒数，如果调用失败则返回-1。      
为了说明alarm函数的工作情况，我们通过使用fork、sleep和signal来模拟它的效果。程序可以启动一个新的进程，它专门用于在未来的某一时刻发送一个信号。          
#####模拟一个闹钟
程序里的第一个函数ding的作用是模拟一个闹钟            
在main函数中，我们告诉子进程在等待5秒后发送一个SIGALRM信号给它的父进程。            
父进程通过一个signal调用安排好捕获SIGALRM信号的工作，然后等待它的到来。         
运行这个程序时，它会暂停5秒，等待模拟闹钟的闹钟。      
```c
#include <sys/types.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

static int alarm_fired = 0;

void ding(int sig)
{
	alarm_fired = 1;
}

int main(int argc, char *argv[])
{
	pid_t pid;

	printf("alarm appliaction starting\n");

	pid = fork();
	switch(pid) {
		case -1:
			perror("fork failed");
			exit(1);
		case 0:
			sleep(5);
			kill(getppid(), SIGALRM);
			exit(0);
	}

	printf("waiting for alarm to go off\n");
	signal(SIGALRM, ding);

	pause();
	if (alarm_fired)
		printf("Ding\n");

	printf("done\n");
	exit(0);
}
```
这个程序用到了一个新的函数pause，它的作用很简单，就是把程序的执行挂起直到有一个信号出现为止。当程序接收到一个信号时，预设好的信号处理函数将开始运行，程序也将恢复正常的执行。pause函数的定义如下所示：
```c
#include <unistd.h>

int pause(void);
```
当它被一个中断时，将返回-1(如果下一个接收到的信号没有导致程序终止的话)并把errno设置为EINTR。当需要等待信号时，一个更常见的方法是使用稍后将要介绍的sigsuspend函数。           





```c
#include <signal.h>

void (*signal(int signum, void(* handler)(int)))(int);
typedef void(*sig_t) (int);
sig_t signal(int signum, sig_t handler);
```
参数1   我们要进行处理的信号，系统的信号我们可以在终端键入`kill -l`查看(共64个),其实这些信号是系统定义的宏     
参数2   我们处理的方式(是系统默认还是忽略还是捕获)       
```c
void (*signal(int signum, void(*handler)(int)))(int);
```
可以看成是signal函数(,它自己带2个参数,一个为整型，一个为函数指针的函数)          
而这个signal函数的返回值也是一个函数指针，这个函数指针指向一个带一个整型参数，并且返回值为int的一个函数
```c
#include <stdio.h>
#include <signal.h>

void myFunc();

int main(int argc, char *argv[])
{
	signal(SIGINT, myFunc);
	pause();
	return 0;
}

void myFunc()
{
	int i = 0;
	for(; i<10; i++) {
		printf("%d\n", i);
	}
}
```
现在，我们就给`Ctrl+c`安装了一个信号,当我们按下`Ctrl+c`后，就会执行myFunc函数了

#####信号安装函数sigaction
```c
sigaction(int signum, const struct sigaction *cat, struct sigaction *oldact);
```
第二个参数是一个指向sigaction结构的指针（结构体名称与函数名一样，千万别弄混淆了）       
在结构sigaction的实例中，指定了对特定信号的处理，信号所传递的信息，信号处理函数执行过程中应屏蔽掉哪些函数等。当然，此指针也可以为NULL，进程会以默认方式处理信号  

对于内核头文件而言，struct sigaction 结构体定义在kernel/include/asm/signal.h,此头文件又被kernel/include/linux/signal.h包含           
现在我们使用信号安装函数实现上面的程序
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

void myFunc();

int main(int argc, char *argv[])
{
	struct sigaction sa;

	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = myFunc;
	sigaction(SIGINT, &sa, NULL);
	pause();
	return 0;
}

void myFunc()
{
	int i = 0;
	for(; i<10; i++) {
		printf("%d\n", i);
	}
}
```
现在，我们就给`Ctrl+c`安装了一个信号,当我们按下`Ctrl+c`后，就会执行myFunc函数了        

对于用户空间的头文件而言，struct sigaction定义在 /usr/include/bits/sigaction.h,此头文件又被/usr/include/signal.h包含，所以应用程序中如果用到此结构，只要#include <signal.h>即可。注意内核中的定义和应用程序中的定义是不一样的，内核空间的sigaction结构只支持函数类型为 __sighandler_t的信号处理函数，不能处理信号传递的额外信息。具体定义如下
```c
typedef void (*__sighandler_t)(int);

#ifdef __KERNEL__
struct old_sigaction {
		__sighandler_t sa_handler;
		old_sigset sa_mask;
		unsigned long sa_flags;
		void (*sa_restorer)(void);
};

struct sigaction {
		__sighandler_t sa_handler;
		unsigned long sa_flags;
		void (*sa_restorer)(void);
		sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
}

#else

struct sigaction {
		union {
				__sighandler_t _sa_handler;
				void (*_sa_sigaction)(int, struct siginfo *, void *);
		} _u;
		sigset_t sa_mask;
		unsigned long sa_flags;
		void (*sa_restorer)(void);
};

#define sa_handler _u_sa_handler
#define sa_sigaction _u_sa_sigaction
#endif /* __KERNEL__ */
```
sa_handler   原型是一个参数为int，返回类型为void的函数指针。参数即为信号值，所以信号不能传递除信号值之外的任何信息        
sa_sigaction 原型是一个带三个参数，类型分别为int，struct siginfo *，void *,返回类型为void的函数指针。第一个参数为信号值;第二个参数是一个指向struct siginfo结构的指针，此结构中包含信号携带的数据值;第三个参数没有使用       
sa_mask     指定在信号处理程序执行过程中，哪些信号应当被阻塞。默认当前信号本身被阻塞     
sa_flags    包含了许多标志位，比较重要的一个是SA_SIGINFO，当设定了该标志位时，表示信号附带的参数可以传递到信号处理函数中。即使sa_sigaction指定信号处理函数，如果不设置SA_SIGINFO，信号处理函数同样不能得到信号传递过来的数据，在信号处理函数中对这些信息的访问都将导致段错误        
